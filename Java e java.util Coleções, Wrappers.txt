Java e java.util: Coleções, Wrappers e Lambda expressions

Estruturas de dados: Precisamos de formas mais enxutas de armazenamento de dados, e para isso existem as estruturas de dados.

1ª Arrays [ ]:

 - Utiliza conchetes para utilizar arrays:
		Tipo de dado[ ] - Ex: String[]

- Arrays são objetos:
		 int [] idades = new int [5];

- Arrays começam com 0 (zero);

Internamente, temos um processo que começa com uma pilha de execução, representada pelo método main. Nesta pilha, ou seja, no método, foi criada uma variável idades.

Esta variável é um array, que como vimos, é um objeto. Os objetos ficam armazenados na memória HEAP. Assim, idades é uma referência que aponta para um objeto na memória, capaz de guardar cinco idades.

Utilizamos a variável como referência e precisamos informar a posição que queremos acessar dentro de colchetes ([]). Por exemplo, se quisermos acessar a primeira posição, ela é representada pelo número 0:

		idades[0]

Incializando um array (inserindo dados):
 
		 idades[0] = 29;

	int idade1 = idades[0];

Um array é:

1 - Array é uma estrutura de dados.

2 - Um array é sempre inicializado com os valores padrões. cada posição do array é inicializada com o valor padrão. Qual é esse valor padrão? O tipo do array define. Por exemplo, no array do tipo int o valor padrão é 0, no double o valor padrão é 0.0.

3 - Um array é sempre zero-based (o primeiro elemento se encontra no index 0).

A SINTAXE DO ARRAY

Definimos o tamanho na hora de criar o array.

	double[] precos = new double[5];

ARRAY DE REFERÊNCIA

Sintaxe:

		ContaCorrente[] contas = new ContaCorrente[5];

Padrão de referência de um array de referência  é NULL

FORMA LITERAL

Até agora vimos a forma "classica" de criar um objeto array usando a palavra chave new, por exemplo:

			int[] numeros = new int[5];

numeros[0] = 1;
numeros[1] = 2;
numeros[2] = 3;
numeros[3] = 4;
numeros[4] = 5;

Usar valores diretamente, menos burocrático, mais direito.

			int[] refs = {1,2,3,4,5};

Usamos as chaves {} para indicar que se trata de um array e os valores já ficam declarados dentro das chaves.

RESUMO:

- Um array é uma estrutura de dados e serve para guardar elementos (valores primitivos ou referências);

- Arrays usam colchetes ([]) sintaticamente;

- Arrays têm um tamanho fixo!

- Um array também é um objeto!;

- Arrays são zero-based (o primeiro elemento se encontra na posição 0);

- Um array é sempre inicializado com os valores padrões;

- Ao acessar uma posição inválida recebemos a exceção ArrayIndexOutOfBoundException;

- Arrays possuem um atributo length para saber o tamanho
A forma literal de criar uma Array, com o uso de chaves {}.


CAP 2: GUARDANDO QUALQUER REFERÊNCIA

Array do tipo OBJECT

Conta[] contas2 = new Conta[5]; - Contas do nível mais genérico 

Type cast 

transforma a ref tipo (génerica) conta para um ref (mais especifica) tipo conta popança.

			 ContaPoupanca ref = (ContaPoupanca) contas[1];

Array que guarda qualquer tipo de dados:

	Object [ ] banco = new Object [5];	

CAST IMPLÍCITO E EXPLÍCITO DE PRIMITIVOS

o primeiro do mundo de primitivos:

int numero = 3;
double valor = numero; //cast implícito

Repare que colocamos um valor da variável numero (tipo int) na variável valor (tipo double), sem usar um cast explícito. Isso funciona? A resposta é sim, pois qualquer inteiro cabe dentro de um double. Por isso o compilador fica quieto e não exige um cast explicito, mas nada impede de escrever:

	int numero = 3;
	double valor = (double) numero; //cast explícito


Agora, o contrário não funciona sem cast, uma vez que um double NÃO cabe em um int:

		double valor = 3.56;
		int numero = (int) valor; //cast explicito é exigido pelo compilador

Nesse caso o compilador joga todo valor fracional fora e guarda apenas o valor inteiro.

	CAST IMPLÍCITO E EXPLÍCITO DE REFERÊNCIAS

*Nas referências, o mesmo princípio se aplica. Se o cast sempre funciona não é necessário deixá-lo explícito*

		ContaCorrente cc1 = new ContaCorrente(22, 33);
		Conta conta = cc1; //cast implicito 

Aqui também poderia ser explícito, mas novamente, o compilador não exige pois qualquer ContaCorrente é uma Conta:

		ContaCorrente cc1 = new ContaCorrente(22, 33);
		Conta conta = (Conta) cc1; //cast explícito mas desnecessário 

TYPE CAST EXPLÍCITO SEMPRE FUNCIONA?

A resposta é NÃO. O cast explicito só funciona se ele for possível, mas há casos em que o compilador sabe que um cast é impossível e aí nem compila, nem com type cast.

		Cliente cliente = new Cliente();
		Conta conta = (Conta) cliente; //impossível, não compila


Como o cliente não ESTENDE a classe Conta ou IMPLEMENTA uma INTERFACE do tipo Conta, é impossível esse cast funcionar, pois uma referência do tipo Conta jamais pode apontar para um objeto do tipo Cliente.

A certificação Java tem muitas dessas perguntas sobre cast possível, impossível, explícito e implícito. Se você pretende tirar essa certificação, vale a pena estudar esse assunto com muita calma.git init

EXEÇÕES DO TYPE CAST

SOBRE ClassCastException

1 - é do pacote java.lang
2 - É lançada quando o type cast falha
3 - A ClassCastException é unchecked pois estende RuntimeException.

ENTENDENDO O ARRAY STRING ARGS

Acessa pelo terminal cmd 
1 - ls = saber onde está a pasta (está dentro da pasta bin)
2 - cd bin = acessar a pasta bin
3 - ls = mostra a pasta
4 - java joga o caminho da pasta = inicializa a maquina virtual
5 - Já está funcionando no terminal
6 - pode passar parametros e coloca dentro da String acessada pelo terminal


Strings [ ] = Ele existe para que possamos passar parâmetros a partir do terminal


Assim, temos uma forma de interagir com o programa Java a partir da linha de comando. Chamamos a aplicação e, simultaneamente, é possível definirmos parâmetros.

Isso tem várias utilidades. Pode servir, por exemplo, para habilitar alguma funcionalidade, entre várias outras configurações possíveis.

RESUMO:

# uma array do tipo Object pode guardar qualquer tipo de referência;

# quando convertemos uma referência genérica para uma referência mais específica é preciso usar um type cast;

# o cast só compila quando é possível, mesmo assim pode falhar na hora de rodar;

# quando o type cast falha podemos receber uma ClassCastException;

# para receber valores ao chamar o programa Java na linha de comando podemos usar o array String[] no método main;

ARRAYLIST E GENERICS

	Adapter para Arrays

Desvantagens de usar Array:

1 - Sintaxe fora do padrão "OO Java". Os arrays realmente têm a sua própria sintaxe, o que dificulta a legibilidade do código.

2 - Array tem um tamanho fixo (não pode crescer dinamicamente). Uma vez criado, o array sempre terá o mesmo tamanho de elementos. Isso é muito ruim quando não sabemos exatamente quantos elementos precisamos guardar.

3 - Array não sabe quantas posições estão ocupadas (apenas tamanho total). Isso é uma grande desvantagem. Não queremos saber quantos elementos um array pode ter, mas sim quantos elementos realmente já existem no array.

4 - Array é uma estrutura considerada rápida. Pensando no desempenho o array é a estrutura que se destaca.

		ArrayList

O pacote fundamental do java: JAVA.UTIL

Sobre o ArrayList:

a) Guarda referências.

b) É do pacote java.util.

c) Usa internamente um array.

d) Ao inicializar NÃO é preciso definir o tamanho

O java.util.ArrayList é realmente um guardador de referências e usa um array internamente.Correto, o java.util.ArrayList é realmente um guardador de referências e usa um array internamente.

Adicionando referências no ArrayList o elemento é adicionado no fim da lista.

Elementos que o ArrayList pode guardar o limite é a memória da JVM. O único limite é a memória da JVM.

	
	Introdução ao GENERICS < >

Os generics entraram na versão 1.5 na plataforma Java e foram levemente melhorados no Java 1.7. 

Como não misturar Classes e guardar um só tipo referências, exemplo: conta, cliente etc, exemplo:

ArrayList <Conta> lista = new ArrayList<Conta>();

< > = chamado de GENERICS

Antes de especificar o tipo de dados guardados pelo array, o for para saber as contas salvas é esse:

for(Object oRef : lista) { 
            System.out.println(oRef);
}

Após especificar o tipo de dados que o Array vai guardar o for precisa mudar para o console exibir as contas dentro do ArrayList:


for(Conta conta : lista) { 
            System.out.println(conta);
}

Agora ele não vai exibir todos os dados salvos (Object) independente da classe, exemplo Cliente, Conta etc, mas só os dados salvos no ArrayList da Conta.


Código legado


ArrayList lista = new ArrayList();
Cliente cliente = new Cliente();
lista.add(cliente);

Nova forma de fazer: 

		ArrayList<Cliente> lista = new ArrayList<Cliente>();

Atualização do java.1.7:

parametrizamos a ArrayList usando <>. Há uma variação/simplificação que entrou no Java 1.7. O código abaixo é equivalente a alternativa:

			ArrayList<Cliente> lista = new ArrayList<>();

Beneficios de usar o Generics < > 

1 - Antecipar problemas de casts no momento de compilação. Antecipar problemas de casts no momento de compilação:
		ArrayList<String> lista = new ArrayList<String>(); 
		lista.add("Nico");
		Conta c = lista.get(0); //nao compila
//erro pois tem erro no tipo: .add e não .get

2 - Evitar casts excessivos. Uma vez parametrizada a lista, não precisamos mais o cast

		Cliente ref = (Cliente) lista.get(0); // desnecessário com generics

3 - O código mais legível, já que fica explícito o tipo dos elementos. Na criação da lista fica claro qual a intenção. Por exemplo, na declaração abaixo está bem claro que a lista guarda Strings:

		ArrayList<String> nomes = new ArrayList<String>(); 

4 - Em geral, o compilador Java não otimiza o código. Isso é a tarefa da JVM. Os generics ajudam na hora de escrever o código, na hora de rodar não há impacto.


OUTRAS FORMAS DE INICIALIZAÇÃO

		Lista com capacidade predefinida

ArrayList é um array dinâmico, ou seja, por baixo dos panos é usado um array, mas sem se preocupar com os detalhes e limitações.

Agora pense que você precisa criar uma lista representando todos os 26 estados do Brasil. Você gostaria de usar um ArrayList para "fugir" do array, mas sabe que o ArrayList cria um array automaticamente, do tamanho que a classe acha conveniente.

Será que não há uma forma de criar essa lista já definindo o tamanho do array? Claro que tem e é muito simples. O construtor da classe ArrayList é sobrecarregado e possui um parâmetro que recebe a capacidade:

		ArrayList lista = new ArrayList(26); //capacidade inicial

ArrayList lista = new ArrayList(26); //capacidade inicial

		Lista a partir de outra

Outra forma de inicializar uma lista é baseado na outra que é muito comum no dia a dia. Para tal a ArrayList possui mais um construtor que recebe a lista base:

ArrayList lista = new ArrayList(26); //capacidade inicial
lista.add("RJ");
lista.add("SP");
//outros estados
ArrayList nova = new ArrayList(lista); //criando baseado na primeira lista

RESUMO

Nessa aula começamos a falar sobre lista e conhecemos a classe java.util.ArrayList. Aprendemos:

# que a classe java.util.ArrayList encapsula o uso do array e oferece vários métodos de mais alto nível

# que uma lista guarda referencias

# como usar métodos size, get, remove

# como usar a sintaxe foreach para iterar a ArrayList

# que os generics parametrizam classes

# que no caso da ArrayList podemos definir o tipo dos elementos através de generics








