Java e java.util: Coleções, Wrappers e Lambda expressions

Estruturas de dados: Precisamos de formas mais enxutas de armazenamento de dados, e para isso existem as estruturas de dados.

1ª Arrays [ ]:

 - Utiliza conchetes para utilizar arrays:
		Tipo de dado[ ] - Ex: String[]

- Arrays são objetos:
		 int [] idades = new int [5];

- Arrays começam com 0 (zero);

Internamente, temos um processo que começa com uma pilha de execução, representada pelo método main. Nesta pilha, ou seja, no método, foi criada uma variável idades.

Esta variável é um array, que como vimos, é um objeto. Os objetos ficam armazenados na memória HEAP. Assim, idades é uma referência que aponta para um objeto na memória, capaz de guardar cinco idades.

Utilizamos a variável como referência e precisamos informar a posição que queremos acessar dentro de colchetes ([]). Por exemplo, se quisermos acessar a primeira posição, ela é representada pelo número 0:

		idades[0]

Incializando um array (inserindo dados):
 
		 idades[0] = 29;

	int idade1 = idades[0];

Um array é:

1 - Array é uma estrutura de dados.

2 - Um array é sempre inicializado com os valores padrões. cada posição do array é inicializada com o valor padrão. Qual é esse valor padrão? O tipo do array define. Por exemplo, no array do tipo int o valor padrão é 0, no double o valor padrão é 0.0.

3 - Um array é sempre zero-based (o primeiro elemento se encontra no index 0).

A SINTAXE DO ARRAY

Definimos o tamanho na hora de criar o array.

	double[] precos = new double[5];

ARRAY DE REFERÊNCIA

Sintaxe:

		ContaCorrente[] contas = new ContaCorrente[5];

Padrão de referência de um array de referência  é NULL

FORMA LITERAL

Até agora vimos a forma "classica" de criar um objeto array usando a palavra chave new, por exemplo:

			int[] numeros = new int[5];

numeros[0] = 1;
numeros[1] = 2;
numeros[2] = 3;
numeros[3] = 4;
numeros[4] = 5;

Usar valores diretamente, menos burocrático, mais direito.

			int[] refs = {1,2,3,4,5};

Usamos as chaves {} para indicar que se trata de um array e os valores já ficam declarados dentro das chaves.

RESUMO:

- Um array é uma estrutura de dados e serve para guardar elementos (valores primitivos ou referências);

- Arrays usam colchetes ([]) sintaticamente;

- Arrays têm um tamanho fixo!

- Um array também é um objeto!;

- Arrays são zero-based (o primeiro elemento se encontra na posição 0);

- Um array é sempre inicializado com os valores padrões;

- Ao acessar uma posição inválida recebemos a exceção ArrayIndexOutOfBoundException;

- Arrays possuem um atributo length para saber o tamanho
A forma literal de criar uma Array, com o uso de chaves {}.


CAP 2: GUARDANDO QUALQUER REFERÊNCIA

Array do tipo OBJECT

Conta[] contas2 = new Conta[5]; - Contas do nível mais genérico 

Type cast 

transforma a ref tipo (génerica) conta para um ref (mais especifica) tipo conta popança.

			 ContaPoupanca ref = (ContaPoupanca) contas[1];

Array que guarda qualquer tipo de dados:

	Object [ ] banco = new Object [5];	

CAST IMPLÍCITO E EXPLÍCITO DE PRIMITIVOS

o primeiro do mundo de primitivos:

int numero = 3;
double valor = numero; //cast implícito

Repare que colocamos um valor da variável numero (tipo int) na variável valor (tipo double), sem usar um cast explícito. Isso funciona? A resposta é sim, pois qualquer inteiro cabe dentro de um double. Por isso o compilador fica quieto e não exige um cast explicito, mas nada impede de escrever:

	int numero = 3;
	double valor = (double) numero; //cast explícito


Agora, o contrário não funciona sem cast, uma vez que um double NÃO cabe em um int:

		double valor = 3.56;
		int numero = (int) valor; //cast explicito é exigido pelo compilador

Nesse caso o compilador joga todo valor fracional fora e guarda apenas o valor inteiro.

	CAST IMPLÍCITO E EXPLÍCITO DE REFERÊNCIAS

*Nas referências, o mesmo princípio se aplica. Se o cast sempre funciona não é necessário deixá-lo explícito*

		ContaCorrente cc1 = new ContaCorrente(22, 33);
		Conta conta = cc1; //cast implicito 

Aqui também poderia ser explícito, mas novamente, o compilador não exige pois qualquer ContaCorrente é uma Conta:

		ContaCorrente cc1 = new ContaCorrente(22, 33);
		Conta conta = (Conta) cc1; //cast explícito mas desnecessário 

TYPE CAST EXPLÍCITO SEMPRE FUNCIONA?

A resposta é NÃO. O cast explicito só funciona se ele for possível, mas há casos em que o compilador sabe que um cast é impossível e aí nem compila, nem com type cast.

		Cliente cliente = new Cliente();
		Conta conta = (Conta) cliente; //impossível, não compila


Como o cliente não ESTENDE a classe Conta ou IMPLEMENTA uma INTERFACE do tipo Conta, é impossível esse cast funcionar, pois uma referência do tipo Conta jamais pode apontar para um objeto do tipo Cliente.

A certificação Java tem muitas dessas perguntas sobre cast possível, impossível, explícito e implícito. Se você pretende tirar essa certificação, vale a pena estudar esse assunto com muita calma.





